{"ast":null,"code":"import axios from 'axios';\n\n/**\n * Функция для выполнения запросов с автоматическими повторными попытками и\n * проверкой доступности API на разных портах\n * \n * @param {string} url - URL запроса (относительный или абсолютный)\n * @param {object} options - Параметры для axios\n * @param {number} maxRetries - Максимальное количество попыток запроса\n * @returns {Promise<any>} - Данные ответа\n */\nexport const fetchWithRetry = async (url, options = {}, maxRetries = 3) => {\n  let lastError = null;\n  let currentPort = null;\n\n  // Проверка соединения через различные порты если базовый URL не работает\n  for (let attempt = 0; attempt < maxRetries; attempt++) {\n    try {\n      if (attempt > 0) {\n        console.log(`Повторная попытка #${attempt} запроса к ${url}`);\n      }\n      if (attempt === 1 && !currentPort) {\n        // Проверим здоровье API через относительный URL\n        try {\n          await axios.get('/api/health');\n          console.log('API доступен через прокси');\n          // Если работает, используем текущие настройки\n        } catch (healthError) {\n          console.log('API недоступен через прокси:', healthError.message);\n          // Пробуем напрямую через порты\n          for (const port of [5001, 5002, 5003, 5004, 5005]) {\n            try {\n              console.log(`Проверка API на порту ${port}...`);\n              const response = await axios.get(`http://localhost:${port}/api/health`);\n              if (response.data.status === 'healthy') {\n                console.log(`API найден на порту ${port}`);\n                currentPort = port;\n                axios.defaults.baseURL = `http://localhost:${port}/api`;\n                break;\n              }\n            } catch (portError) {\n              console.log(`Порт ${port} недоступен:`, portError.message);\n            }\n          }\n        }\n      }\n\n      // Выполняем основной запрос\n      const method = options.method || 'get';\n      let response;\n      if (method.toLowerCase() === 'get') {\n        response = await axios.get(url, options);\n      } else if (method.toLowerCase() === 'post') {\n        response = await axios.post(url, options.data, options);\n      } else if (method.toLowerCase() === 'put') {\n        response = await axios.put(url, options.data, options);\n      } else if (method.toLowerCase() === 'delete') {\n        response = await axios.delete(url, options);\n      } else {\n        response = await axios(url, options);\n      }\n      return response.data;\n    } catch (error) {\n      console.error(`Ошибка при попытке #${attempt + 1}:`, error);\n      lastError = error;\n\n      // Если ошибка авторизации, не повторяем запрос\n      if (error.response && error.response.status === 401) {\n        throw error;\n      }\n\n      // Пауза перед следующей попыткой\n      if (attempt < maxRetries - 1) {\n        await new Promise(resolve => setTimeout(resolve, 1000 * (attempt + 1)));\n      }\n    }\n  }\n\n  // Если все попытки не удались, создаем информативную ошибку\n  const errorInfo = lastError.response ? {\n    status: lastError.response.status,\n    data: lastError.response.data,\n    message: 'Превышено количество попыток загрузки данных'\n  } : {\n    message: lastError.message || 'Ошибка соединения с сервером'\n  };\n  throw new Error(JSON.stringify(errorInfo));\n};\n\n/**\n * Функция для проверки доступности сервера API\n */\nexport const checkApiHealth = async () => {\n  try {\n    const response = await fetchWithRetry('/api/health');\n    return {\n      healthy: response.status === 'healthy',\n      database: response.database === 'connected',\n      message: 'API доступен',\n      details: response\n    };\n  } catch (error) {\n    return {\n      healthy: false,\n      database: false,\n      message: 'API недоступен',\n      error\n    };\n  }\n};\n\n/**\n * Функция для инициализации настроек API\n */\nexport const initializeApi = async () => {\n  const ports = [5001, 5002, 5003, 5004, 5005];\n\n  // Сначала проверяем через прокси\n  try {\n    const response = await axios.get('/api/health');\n    if (response.data.status === 'healthy') {\n      console.log('API доступен через прокси');\n      return true;\n    }\n  } catch (error) {\n    console.log('API недоступен через прокси:', error.message);\n  }\n\n  // Затем проверяем все порты напрямую\n  for (const port of ports) {\n    try {\n      const response = await axios.get(`http://localhost:${port}/api/health`);\n      if (response.data.status === 'healthy') {\n        console.log(`API найден на порту ${port}`);\n        axios.defaults.baseURL = `http://localhost:${port}/api`;\n        return true;\n      }\n    } catch (error) {\n      // Игнорируем ошибки\n    }\n  }\n  console.error('Не удалось подключиться к API ни на одном порту');\n  return false;\n};","map":{"version":3,"names":["axios","fetchWithRetry","url","options","maxRetries","lastError","currentPort","attempt","console","log","get","healthError","message","port","response","data","status","defaults","baseURL","portError","method","toLowerCase","post","put","delete","error","Promise","resolve","setTimeout","errorInfo","Error","JSON","stringify","checkApiHealth","healthy","database","details","initializeApi","ports"],"sources":["/Users/apple/Desktop/диплом/client/src/utils/apiUtils.js"],"sourcesContent":["import axios from 'axios';\n\n/**\n * Функция для выполнения запросов с автоматическими повторными попытками и\n * проверкой доступности API на разных портах\n * \n * @param {string} url - URL запроса (относительный или абсолютный)\n * @param {object} options - Параметры для axios\n * @param {number} maxRetries - Максимальное количество попыток запроса\n * @returns {Promise<any>} - Данные ответа\n */\nexport const fetchWithRetry = async (url, options = {}, maxRetries = 3) => {\n  let lastError = null;\n  let currentPort = null;\n  \n  // Проверка соединения через различные порты если базовый URL не работает\n  for (let attempt = 0; attempt < maxRetries; attempt++) {\n    try {\n      if (attempt > 0) {\n        console.log(`Повторная попытка #${attempt} запроса к ${url}`);\n      }\n      \n      if (attempt === 1 && !currentPort) {\n        // Проверим здоровье API через относительный URL\n        try {\n          await axios.get('/api/health');\n          console.log('API доступен через прокси');\n          // Если работает, используем текущие настройки\n        } catch (healthError) {\n          console.log('API недоступен через прокси:', healthError.message);\n          // Пробуем напрямую через порты\n          for (const port of [5001, 5002, 5003, 5004, 5005]) {\n            try {\n              console.log(`Проверка API на порту ${port}...`);\n              const response = await axios.get(`http://localhost:${port}/api/health`);\n              if (response.data.status === 'healthy') {\n                console.log(`API найден на порту ${port}`);\n                currentPort = port;\n                axios.defaults.baseURL = `http://localhost:${port}/api`;\n                break;\n              }\n            } catch (portError) {\n              console.log(`Порт ${port} недоступен:`, portError.message);\n            }\n          }\n        }\n      }\n      \n      // Выполняем основной запрос\n      const method = options.method || 'get';\n      let response;\n      \n      if (method.toLowerCase() === 'get') {\n        response = await axios.get(url, options);\n      } else if (method.toLowerCase() === 'post') {\n        response = await axios.post(url, options.data, options);\n      } else if (method.toLowerCase() === 'put') {\n        response = await axios.put(url, options.data, options);\n      } else if (method.toLowerCase() === 'delete') {\n        response = await axios.delete(url, options);\n      } else {\n        response = await axios(url, options);\n      }\n      \n      return response.data;\n    } catch (error) {\n      console.error(`Ошибка при попытке #${attempt + 1}:`, error);\n      lastError = error;\n      \n      // Если ошибка авторизации, не повторяем запрос\n      if (error.response && error.response.status === 401) {\n        throw error;\n      }\n      \n      // Пауза перед следующей попыткой\n      if (attempt < maxRetries - 1) {\n        await new Promise(resolve => setTimeout(resolve, 1000 * (attempt + 1)));\n      }\n    }\n  }\n  \n  // Если все попытки не удались, создаем информативную ошибку\n  const errorInfo = lastError.response ? {\n    status: lastError.response.status,\n    data: lastError.response.data,\n    message: 'Превышено количество попыток загрузки данных'\n  } : {\n    message: lastError.message || 'Ошибка соединения с сервером'\n  };\n  \n  throw new Error(JSON.stringify(errorInfo));\n};\n\n/**\n * Функция для проверки доступности сервера API\n */\nexport const checkApiHealth = async () => {\n  try {\n    const response = await fetchWithRetry('/api/health');\n    return {\n      healthy: response.status === 'healthy',\n      database: response.database === 'connected',\n      message: 'API доступен',\n      details: response\n    };\n  } catch (error) {\n    return {\n      healthy: false,\n      database: false,\n      message: 'API недоступен',\n      error\n    };\n  }\n};\n\n/**\n * Функция для инициализации настроек API\n */\nexport const initializeApi = async () => {\n  const ports = [5001, 5002, 5003, 5004, 5005];\n  \n  // Сначала проверяем через прокси\n  try {\n    const response = await axios.get('/api/health');\n    if (response.data.status === 'healthy') {\n      console.log('API доступен через прокси');\n      return true;\n    }\n  } catch (error) {\n    console.log('API недоступен через прокси:', error.message);\n  }\n  \n  // Затем проверяем все порты напрямую\n  for (const port of ports) {\n    try {\n      const response = await axios.get(`http://localhost:${port}/api/health`);\n      if (response.data.status === 'healthy') {\n        console.log(`API найден на порту ${port}`);\n        axios.defaults.baseURL = `http://localhost:${port}/api`;\n        return true;\n      }\n    } catch (error) {\n      // Игнорируем ошибки\n    }\n  }\n  \n  console.error('Не удалось подключиться к API ни на одном порту');\n  return false;\n}; "],"mappings":"AAAA,OAAOA,KAAK,MAAM,OAAO;;AAEzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMC,cAAc,GAAG,MAAAA,CAAOC,GAAG,EAAEC,OAAO,GAAG,CAAC,CAAC,EAAEC,UAAU,GAAG,CAAC,KAAK;EACzE,IAAIC,SAAS,GAAG,IAAI;EACpB,IAAIC,WAAW,GAAG,IAAI;;EAEtB;EACA,KAAK,IAAIC,OAAO,GAAG,CAAC,EAAEA,OAAO,GAAGH,UAAU,EAAEG,OAAO,EAAE,EAAE;IACrD,IAAI;MACF,IAAIA,OAAO,GAAG,CAAC,EAAE;QACfC,OAAO,CAACC,GAAG,CAAC,sBAAsBF,OAAO,cAAcL,GAAG,EAAE,CAAC;MAC/D;MAEA,IAAIK,OAAO,KAAK,CAAC,IAAI,CAACD,WAAW,EAAE;QACjC;QACA,IAAI;UACF,MAAMN,KAAK,CAACU,GAAG,CAAC,aAAa,CAAC;UAC9BF,OAAO,CAACC,GAAG,CAAC,2BAA2B,CAAC;UACxC;QACF,CAAC,CAAC,OAAOE,WAAW,EAAE;UACpBH,OAAO,CAACC,GAAG,CAAC,8BAA8B,EAAEE,WAAW,CAACC,OAAO,CAAC;UAChE;UACA,KAAK,MAAMC,IAAI,IAAI,CAAC,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,CAAC,EAAE;YACjD,IAAI;cACFL,OAAO,CAACC,GAAG,CAAC,yBAAyBI,IAAI,KAAK,CAAC;cAC/C,MAAMC,QAAQ,GAAG,MAAMd,KAAK,CAACU,GAAG,CAAC,oBAAoBG,IAAI,aAAa,CAAC;cACvE,IAAIC,QAAQ,CAACC,IAAI,CAACC,MAAM,KAAK,SAAS,EAAE;gBACtCR,OAAO,CAACC,GAAG,CAAC,uBAAuBI,IAAI,EAAE,CAAC;gBAC1CP,WAAW,GAAGO,IAAI;gBAClBb,KAAK,CAACiB,QAAQ,CAACC,OAAO,GAAG,oBAAoBL,IAAI,MAAM;gBACvD;cACF;YACF,CAAC,CAAC,OAAOM,SAAS,EAAE;cAClBX,OAAO,CAACC,GAAG,CAAC,QAAQI,IAAI,cAAc,EAAEM,SAAS,CAACP,OAAO,CAAC;YAC5D;UACF;QACF;MACF;;MAEA;MACA,MAAMQ,MAAM,GAAGjB,OAAO,CAACiB,MAAM,IAAI,KAAK;MACtC,IAAIN,QAAQ;MAEZ,IAAIM,MAAM,CAACC,WAAW,CAAC,CAAC,KAAK,KAAK,EAAE;QAClCP,QAAQ,GAAG,MAAMd,KAAK,CAACU,GAAG,CAACR,GAAG,EAAEC,OAAO,CAAC;MAC1C,CAAC,MAAM,IAAIiB,MAAM,CAACC,WAAW,CAAC,CAAC,KAAK,MAAM,EAAE;QAC1CP,QAAQ,GAAG,MAAMd,KAAK,CAACsB,IAAI,CAACpB,GAAG,EAAEC,OAAO,CAACY,IAAI,EAAEZ,OAAO,CAAC;MACzD,CAAC,MAAM,IAAIiB,MAAM,CAACC,WAAW,CAAC,CAAC,KAAK,KAAK,EAAE;QACzCP,QAAQ,GAAG,MAAMd,KAAK,CAACuB,GAAG,CAACrB,GAAG,EAAEC,OAAO,CAACY,IAAI,EAAEZ,OAAO,CAAC;MACxD,CAAC,MAAM,IAAIiB,MAAM,CAACC,WAAW,CAAC,CAAC,KAAK,QAAQ,EAAE;QAC5CP,QAAQ,GAAG,MAAMd,KAAK,CAACwB,MAAM,CAACtB,GAAG,EAAEC,OAAO,CAAC;MAC7C,CAAC,MAAM;QACLW,QAAQ,GAAG,MAAMd,KAAK,CAACE,GAAG,EAAEC,OAAO,CAAC;MACtC;MAEA,OAAOW,QAAQ,CAACC,IAAI;IACtB,CAAC,CAAC,OAAOU,KAAK,EAAE;MACdjB,OAAO,CAACiB,KAAK,CAAC,uBAAuBlB,OAAO,GAAG,CAAC,GAAG,EAAEkB,KAAK,CAAC;MAC3DpB,SAAS,GAAGoB,KAAK;;MAEjB;MACA,IAAIA,KAAK,CAACX,QAAQ,IAAIW,KAAK,CAACX,QAAQ,CAACE,MAAM,KAAK,GAAG,EAAE;QACnD,MAAMS,KAAK;MACb;;MAEA;MACA,IAAIlB,OAAO,GAAGH,UAAU,GAAG,CAAC,EAAE;QAC5B,MAAM,IAAIsB,OAAO,CAACC,OAAO,IAAIC,UAAU,CAACD,OAAO,EAAE,IAAI,IAAIpB,OAAO,GAAG,CAAC,CAAC,CAAC,CAAC;MACzE;IACF;EACF;;EAEA;EACA,MAAMsB,SAAS,GAAGxB,SAAS,CAACS,QAAQ,GAAG;IACrCE,MAAM,EAAEX,SAAS,CAACS,QAAQ,CAACE,MAAM;IACjCD,IAAI,EAAEV,SAAS,CAACS,QAAQ,CAACC,IAAI;IAC7BH,OAAO,EAAE;EACX,CAAC,GAAG;IACFA,OAAO,EAAEP,SAAS,CAACO,OAAO,IAAI;EAChC,CAAC;EAED,MAAM,IAAIkB,KAAK,CAACC,IAAI,CAACC,SAAS,CAACH,SAAS,CAAC,CAAC;AAC5C,CAAC;;AAED;AACA;AACA;AACA,OAAO,MAAMI,cAAc,GAAG,MAAAA,CAAA,KAAY;EACxC,IAAI;IACF,MAAMnB,QAAQ,GAAG,MAAMb,cAAc,CAAC,aAAa,CAAC;IACpD,OAAO;MACLiC,OAAO,EAAEpB,QAAQ,CAACE,MAAM,KAAK,SAAS;MACtCmB,QAAQ,EAAErB,QAAQ,CAACqB,QAAQ,KAAK,WAAW;MAC3CvB,OAAO,EAAE,cAAc;MACvBwB,OAAO,EAAEtB;IACX,CAAC;EACH,CAAC,CAAC,OAAOW,KAAK,EAAE;IACd,OAAO;MACLS,OAAO,EAAE,KAAK;MACdC,QAAQ,EAAE,KAAK;MACfvB,OAAO,EAAE,gBAAgB;MACzBa;IACF,CAAC;EACH;AACF,CAAC;;AAED;AACA;AACA;AACA,OAAO,MAAMY,aAAa,GAAG,MAAAA,CAAA,KAAY;EACvC,MAAMC,KAAK,GAAG,CAAC,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,CAAC;;EAE5C;EACA,IAAI;IACF,MAAMxB,QAAQ,GAAG,MAAMd,KAAK,CAACU,GAAG,CAAC,aAAa,CAAC;IAC/C,IAAII,QAAQ,CAACC,IAAI,CAACC,MAAM,KAAK,SAAS,EAAE;MACtCR,OAAO,CAACC,GAAG,CAAC,2BAA2B,CAAC;MACxC,OAAO,IAAI;IACb;EACF,CAAC,CAAC,OAAOgB,KAAK,EAAE;IACdjB,OAAO,CAACC,GAAG,CAAC,8BAA8B,EAAEgB,KAAK,CAACb,OAAO,CAAC;EAC5D;;EAEA;EACA,KAAK,MAAMC,IAAI,IAAIyB,KAAK,EAAE;IACxB,IAAI;MACF,MAAMxB,QAAQ,GAAG,MAAMd,KAAK,CAACU,GAAG,CAAC,oBAAoBG,IAAI,aAAa,CAAC;MACvE,IAAIC,QAAQ,CAACC,IAAI,CAACC,MAAM,KAAK,SAAS,EAAE;QACtCR,OAAO,CAACC,GAAG,CAAC,uBAAuBI,IAAI,EAAE,CAAC;QAC1Cb,KAAK,CAACiB,QAAQ,CAACC,OAAO,GAAG,oBAAoBL,IAAI,MAAM;QACvD,OAAO,IAAI;MACb;IACF,CAAC,CAAC,OAAOY,KAAK,EAAE;MACd;IAAA;EAEJ;EAEAjB,OAAO,CAACiB,KAAK,CAAC,iDAAiD,CAAC;EAChE,OAAO,KAAK;AACd,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}