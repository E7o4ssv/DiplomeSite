{"ast":null,"code":"import axios from 'axios';\n\n/**\n * Функция для выполнения запросов с автоматическими повторными попытками и\n * проверкой доступности API на разных портах\n * \n * @param {string} url - URL запроса (относительный или абсолютный)\n * @param {object} options - Параметры для axios\n * @param {number} maxRetries - Максимальное количество попыток запроса\n * @returns {Promise<any>} - Данные ответа\n */\nexport const fetchWithRetry = async (url, options = {}, maxRetries = 3) => {\n  let lastError = null;\n  let currentPort = null;\n\n  // Проверка соединения через различные порты если базовый URL не работает\n  for (let attempt = 0; attempt < maxRetries; attempt++) {\n    try {\n      if (attempt > 0) {\n        console.log(`Повторная попытка #${attempt} запроса к ${url}`);\n      }\n      if (attempt === 1 && !currentPort) {\n        // Проверим здоровье API через относительный URL\n        try {\n          await axios.get('/api/health');\n          console.log('API доступен через прокси');\n          // Если работает, используем текущие настройки\n        } catch (healthError) {\n          console.log('API недоступен через прокси:', healthError.message);\n          // Пробуем напрямую через порты\n          for (const port of [5001, 5002, 5003, 5004, 5005]) {\n            try {\n              console.log(`Проверка API на порту ${port}...`);\n              const response = await axios.get(`http://localhost:${port}/api/health`);\n              if (response.data.status === 'healthy') {\n                console.log(`API найден на порту ${port}`);\n                currentPort = port;\n                // Устанавливаем базовый URL без префикса /api, так как он будет добавлен в url\n                axios.defaults.baseURL = `http://localhost:${port}`;\n                break;\n              }\n            } catch (portError) {\n              console.log(`Порт ${port} недоступен:`, portError.message);\n            }\n          }\n        }\n      }\n\n      // Нормализуем URL запроса, убираем двойной префикс /api/api/\n      let requestUrl = url;\n      if (url.startsWith('/api/') && axios.defaults.baseURL && axios.defaults.baseURL.includes('localhost')) {\n        // Если базовый URL настроен на прямое соединение с сервером,\n        // не будем изменять URL, который уже содержит /api/\n        requestUrl = url;\n      } else if (!url.startsWith('/api/') && !url.startsWith('http')) {\n        // Если URL не содержит /api/ и не является абсолютным,\n        // добавим префикс /api/\n        requestUrl = `/api/${url}`;\n      }\n\n      // Выполняем основной запрос\n      const method = options.method || 'get';\n      let response;\n      if (method.toLowerCase() === 'get') {\n        response = await axios.get(requestUrl, options);\n      } else if (method.toLowerCase() === 'post') {\n        response = await axios.post(requestUrl, options.data, options);\n      } else if (method.toLowerCase() === 'put') {\n        response = await axios.put(requestUrl, options.data, options);\n      } else if (method.toLowerCase() === 'delete') {\n        response = await axios.delete(requestUrl, options);\n      } else {\n        response = await axios(requestUrl, options);\n      }\n      return response.data;\n    } catch (error) {\n      console.error(`Ошибка при попытке #${attempt + 1}:`, error);\n      lastError = error;\n\n      // Если ошибка авторизации, не повторяем запрос\n      if (error.response && error.response.status === 401) {\n        throw error;\n      }\n\n      // Пауза перед следующей попыткой\n      if (attempt < maxRetries - 1) {\n        await new Promise(resolve => setTimeout(resolve, 1000 * (attempt + 1)));\n      }\n    }\n  }\n\n  // Если все попытки не удались, создаем информативную ошибку\n  const errorInfo = lastError.response ? {\n    status: lastError.response.status,\n    data: lastError.response.data,\n    message: 'Превышено количество попыток загрузки данных'\n  } : {\n    message: lastError.message || 'Ошибка соединения с сервером'\n  };\n  throw new Error(JSON.stringify(errorInfo));\n};\n\n/**\n * Функция для проверки доступности сервера API\n */\nexport const checkApiHealth = async () => {\n  try {\n    const response = await fetchWithRetry('/api/health');\n    return {\n      healthy: response.status === 'healthy',\n      database: response.database === 'connected',\n      message: 'API доступен',\n      details: response\n    };\n  } catch (error) {\n    return {\n      healthy: false,\n      database: false,\n      message: 'API недоступен',\n      error\n    };\n  }\n};\n\n/**\n * Функция для инициализации настроек API\n */\nexport const initializeApi = async () => {\n  const ports = [5001, 5002, 5003, 5004, 5005];\n\n  // Сначала проверяем через прокси\n  try {\n    const response = await axios.get('/api/health');\n    if (response.data.status === 'healthy') {\n      console.log('API доступен через прокси');\n      return true;\n    }\n  } catch (error) {\n    console.log('API недоступен через прокси:', error.message);\n  }\n\n  // Затем проверяем все порты напрямую\n  for (const port of ports) {\n    try {\n      const response = await axios.get(`http://localhost:${port}/api/health`);\n      if (response.data.status === 'healthy') {\n        console.log(`API найден на порту ${port}`);\n        // Устанавливаем базовый URL без /api\n        axios.defaults.baseURL = `http://localhost:${port}`;\n        return true;\n      }\n    } catch (error) {\n      // Игнорируем ошибки\n    }\n  }\n  console.error('Не удалось подключиться к API ни на одном порту');\n  return false;\n};","map":{"version":3,"names":["axios","fetchWithRetry","url","options","maxRetries","lastError","currentPort","attempt","console","log","get","healthError","message","port","response","data","status","defaults","baseURL","portError","requestUrl","startsWith","includes","method","toLowerCase","post","put","delete","error","Promise","resolve","setTimeout","errorInfo","Error","JSON","stringify","checkApiHealth","healthy","database","details","initializeApi","ports"],"sources":["/Users/apple/Desktop/диплом/client/src/utils/apiUtils.js"],"sourcesContent":["import axios from 'axios';\n\n/**\n * Функция для выполнения запросов с автоматическими повторными попытками и\n * проверкой доступности API на разных портах\n * \n * @param {string} url - URL запроса (относительный или абсолютный)\n * @param {object} options - Параметры для axios\n * @param {number} maxRetries - Максимальное количество попыток запроса\n * @returns {Promise<any>} - Данные ответа\n */\nexport const fetchWithRetry = async (url, options = {}, maxRetries = 3) => {\n  let lastError = null;\n  let currentPort = null;\n  \n  // Проверка соединения через различные порты если базовый URL не работает\n  for (let attempt = 0; attempt < maxRetries; attempt++) {\n    try {\n      if (attempt > 0) {\n        console.log(`Повторная попытка #${attempt} запроса к ${url}`);\n      }\n      \n      if (attempt === 1 && !currentPort) {\n        // Проверим здоровье API через относительный URL\n        try {\n          await axios.get('/api/health');\n          console.log('API доступен через прокси');\n          // Если работает, используем текущие настройки\n        } catch (healthError) {\n          console.log('API недоступен через прокси:', healthError.message);\n          // Пробуем напрямую через порты\n          for (const port of [5001, 5002, 5003, 5004, 5005]) {\n            try {\n              console.log(`Проверка API на порту ${port}...`);\n              const response = await axios.get(`http://localhost:${port}/api/health`);\n              if (response.data.status === 'healthy') {\n                console.log(`API найден на порту ${port}`);\n                currentPort = port;\n                // Устанавливаем базовый URL без префикса /api, так как он будет добавлен в url\n                axios.defaults.baseURL = `http://localhost:${port}`;\n                break;\n              }\n            } catch (portError) {\n              console.log(`Порт ${port} недоступен:`, portError.message);\n            }\n          }\n        }\n      }\n      \n      // Нормализуем URL запроса, убираем двойной префикс /api/api/\n      let requestUrl = url;\n      if (url.startsWith('/api/') && axios.defaults.baseURL && \n          axios.defaults.baseURL.includes('localhost')) {\n        // Если базовый URL настроен на прямое соединение с сервером,\n        // не будем изменять URL, который уже содержит /api/\n        requestUrl = url;\n      } else if (!url.startsWith('/api/') && !url.startsWith('http')) {\n        // Если URL не содержит /api/ и не является абсолютным,\n        // добавим префикс /api/\n        requestUrl = `/api/${url}`;\n      }\n      \n      // Выполняем основной запрос\n      const method = options.method || 'get';\n      let response;\n      \n      if (method.toLowerCase() === 'get') {\n        response = await axios.get(requestUrl, options);\n      } else if (method.toLowerCase() === 'post') {\n        response = await axios.post(requestUrl, options.data, options);\n      } else if (method.toLowerCase() === 'put') {\n        response = await axios.put(requestUrl, options.data, options);\n      } else if (method.toLowerCase() === 'delete') {\n        response = await axios.delete(requestUrl, options);\n      } else {\n        response = await axios(requestUrl, options);\n      }\n      \n      return response.data;\n    } catch (error) {\n      console.error(`Ошибка при попытке #${attempt + 1}:`, error);\n      lastError = error;\n      \n      // Если ошибка авторизации, не повторяем запрос\n      if (error.response && error.response.status === 401) {\n        throw error;\n      }\n      \n      // Пауза перед следующей попыткой\n      if (attempt < maxRetries - 1) {\n        await new Promise(resolve => setTimeout(resolve, 1000 * (attempt + 1)));\n      }\n    }\n  }\n  \n  // Если все попытки не удались, создаем информативную ошибку\n  const errorInfo = lastError.response ? {\n    status: lastError.response.status,\n    data: lastError.response.data,\n    message: 'Превышено количество попыток загрузки данных'\n  } : {\n    message: lastError.message || 'Ошибка соединения с сервером'\n  };\n  \n  throw new Error(JSON.stringify(errorInfo));\n};\n\n/**\n * Функция для проверки доступности сервера API\n */\nexport const checkApiHealth = async () => {\n  try {\n    const response = await fetchWithRetry('/api/health');\n    return {\n      healthy: response.status === 'healthy',\n      database: response.database === 'connected',\n      message: 'API доступен',\n      details: response\n    };\n  } catch (error) {\n    return {\n      healthy: false,\n      database: false,\n      message: 'API недоступен',\n      error\n    };\n  }\n};\n\n/**\n * Функция для инициализации настроек API\n */\nexport const initializeApi = async () => {\n  const ports = [5001, 5002, 5003, 5004, 5005];\n  \n  // Сначала проверяем через прокси\n  try {\n    const response = await axios.get('/api/health');\n    if (response.data.status === 'healthy') {\n      console.log('API доступен через прокси');\n      return true;\n    }\n  } catch (error) {\n    console.log('API недоступен через прокси:', error.message);\n  }\n  \n  // Затем проверяем все порты напрямую\n  for (const port of ports) {\n    try {\n      const response = await axios.get(`http://localhost:${port}/api/health`);\n      if (response.data.status === 'healthy') {\n        console.log(`API найден на порту ${port}`);\n        // Устанавливаем базовый URL без /api\n        axios.defaults.baseURL = `http://localhost:${port}`;\n        return true;\n      }\n    } catch (error) {\n      // Игнорируем ошибки\n    }\n  }\n  \n  console.error('Не удалось подключиться к API ни на одном порту');\n  return false;\n}; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}